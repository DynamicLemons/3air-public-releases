//# address-hook(0x010afa) end(0x010bb8)
function void Character.Initialization.Sonic()
{
	base.Character.Initialization.Sonic()
	setPlayerGlobalValue("mighty_shockwave_t", 0)
	setPlayerGlobalValue("mighty_cam_vlock", 0)
}

//# address-hook(0x010bba) end(0x010c8e)
function void Character.UpdateNormalState.Sonic()
{
	if (isECFCharA0("ECC-Mighty"))
	{
		base.Character.UpdateNormalState.Sonic()
		
		s8 timer = getPlayerGlobalValue("mighty_shockwave_t")
		if (timer > 0)
			setPlayerGlobalValue("mighty_shockwave_t", timer - 1)
		return
	}
	else
		base.Character.UpdateNormalState.Sonic()
}

function void Character.updateJumpMoves()
{
	if (!isECFCharA0("ECC-Mighty"))
	{
		base.Character.updateJumpMoves()
		return
	}
	
	u8 input_state     = Character.getControlVariable(0)
	u8 input_pressed   = Character.getControlVariable(1)
	bool isSuperActive = Character.getSuperState()
	
#if CHARACTER_SELECTION_PLUS_ACTIVE
	bool secondaryMode = (A0 != 0xffffb000 && tails.ai_routine != pAiRoutine_flyInExit && tails.control_counter == 0 && (isSoloMode || !csp_set_fourPlayer))
#else
	bool secondaryMode = false
#endif
		
	if (char.jumping == 2)
	{
		if (char.double_jump_state == 0 && !secondaryMode)
		{
		#if STANDALONE
			if (Input.buttonPressed(BUTTON_Y))
			{
				if (!isSuperActive && char.invuln.countdown == 0)	// Check invulnerability to prevent spamming of super activate + cancel
				{
					if (Character.performSuperTransformation())
						return
				}
			}
		#endif

			// Check if pressed jump again in mid-air
			if (input_pressed & CONTROL_ABC)
			{
			#if STANDALONE
				// Check for other things to do instead of the usual reaction to jump button pressed
				if (onCharacterPressedJumpInMidAir(input_state, input_pressed))
			#endif
					MightyPressedJumpInMidAir()
			}
		}
	}
	else if (char.jumping)
	{
		// Limit velocity.y
		s16 max_vy = (char.flags & char.flag.UNDERWATER) ? -0x200 : -0x400
		if (char.velocity.y < max_vy)
		{
			// Limit vertical velocity while not pressing any jump button
			//  -> This is important to support low jumps by just tapping the button briefly
			if ((input_state & CONTROL_ABC) == 0)
				char.velocity.y = max_vy
		}
	#if !LEMONS_TWEAKS_ACTIVE
		else
	#endif
		{
			if (char.double_jump_state == 0 && !secondaryMode)
			{
				#if STANDALONE
					if (Input.buttonPressed(BUTTON_Y))
					{
						if (!isSuperActive && char.invuln.countdown == 0)	// Check invulnerability to prevent spamming of super activate + cancel
						{
							if (Character.performSuperTransformation())
								return
						}
					}
				#endif

				// Check if pressed jump again in mid-air
				if (input_pressed & CONTROL_ABC)
				{
				#if STANDALONE
					// Check for other things to do instead of the usual reaction to jump button pressed
					if (onCharacterPressedJumpInMidAir(input_state, input_pressed))
				#endif
						MightyPressedJumpInMidAir()
				}
			}
		}
	}
	// Allow for Hammer Drop to cancel into Wall Cling
	else if (char.double_jump_state == 1 && input_pressed & CONTROL_ABC && ecc_setting_mightyWallJump && !secondaryMode)
	{
		Character_checkWallInFront()
		if (D1.s16 <= 10 && (input_state & CONTROL_LEFT && char.flags & char.flag.FACING_LEFT || input_state & CONTROL_RIGHT && (char.flags & char.flag.FACING_LEFT) == 0))
		{
			Mighty_startWallCling()
			return
		}
	}
#if !LEMONS_TWEAKS_ACTIVE
	else
	{
		if (char.spindash == 0)
			char.velocity.y = max(char.velocity.y, -0x0fc0)
	}
#endif
}

function void MightyPressedJumpInMidAir()
{
	u8 input_state     = Character.getControlVariable(0)
	u8 input_pressed   = Character.getControlVariable(1)
	
	if (ecc_setting_mightyWallJump)
	{
		Character_checkWallInFront()
		if (D1.s16 <= 10 && (input_state & CONTROL_LEFT && char.flags & char.flag.FACING_LEFT || input_state & CONTROL_RIGHT && (char.flags & char.flag.FACING_LEFT) == 0))
		{
			Mighty_startWallCling()
			return
		}
	}
		
	// Perform hammer drop!
	//char.velocity.x -= char.velocity.x >> 2
	char.velocity.x >>= 1
	s16 fallSpd = (char.flags & char.flag.UNDERWATER) ? 0x800 : 0xc00
	if (char.velocity.y > fallSpd / 2)
		char.velocity.y += fallSpd / 3
	else 
		char.velocity.y = fallSpd
	char.groundspeed = char.velocity.x
	char.double_jump_state = 1
	char.jumping = 0
	ClearPositionBackup()
	
	char.flags |= char.flag.ROLLING			
	char.flags &= ~char.flag.CONTROL_LOCK
	
	char.state = char.state.MIGHTY_HAMMERDROP
	char.animation.frame = 0
	char.animation.timer = 0
	
	setPlayerGlobalValue("mighty_cam_vlock", 8)
	
	playSound(SFX_SPINDASH_RELEASE) // actually plays in Mania, gives the HD a bit more oomph to it
	Audio.playOverride((ecc_setting_mightyManiaSounds) ? "mighty_drill" : "mighty_c_drill", AudioContext.CONTEXT_SOUND, Character.getCharAudioChannelA(), 1)
}

#if !LEMONS_TWEAKS_ACTIVE
//# address-hook(0x01ab6c) end(0x01ab92)
function void Character.UpdateMovement()
{
	// hard lock Mighty's hammer drop fall speed
	// during playtesting we had quite a bit of noclipping issues that I couldn't recreate.
	if (isECFCharA0("ECC-Mighty") && char.double_jump_state == 1)
	{
		UpdateMovementStraight()
		if (char.velocity.y < 0x1000)
			char.velocity.y = min(char.velocity.y + 0x38, 0x1000)
	}
	else
		base.Character.UpdateMovement()
}
#endif

function void Mighty_startWallCling()
{
	// doing this check here rather than during an input check, to cause less accidental hammer drops.
	if (s16(char.position.y.u16) < s16(level.vertical_wrap) + s16(char.hitbox_extends.y))
		return
		
	if (char.flags & char.flag.FACING_LEFT)
		char.position.x.u16 -= D1.s16
	else
		char.position.x.u16 += D1.s16
	
	setPlayerGlobalValue("mighty_cling_timer", (char.double_jump_state == 1) ? 30 : 0)
	setPlayerGlobalValue("mighty_cling_dustcountdown", 0)
	if (char.velocity.y > 0x380)
		char.velocity.y >>= 3
	else if (char.velocity.y < -0x380)
		char.velocity.y = min(char.velocity.y + 0x380, -0x380)
	else if (char.velocity.y >= 0)
		char.velocity.y = 0
	
	char.state = char.state.MIGHTY_WALLCLING
	playSound(SFX_GRAB)
	char.double_jump_state = 2
}

function bool Character_checkWallInFront()
{	
	pushA456()

	u32[0xfffff796] = (char.layer_flags1 == 0x0c) ? u32[0xfffff7b4] : u32[0xfffff7b8]
	D5.u8 = char.layer_flags2
	
	u8 result
	if (char.flags & char.flag.FACING_LEFT)
	{
		Character.CheckLeftWallCollision()
		if (D1.s16 <= 0)
			result = true
	}
	else
	{
		Character.CheckRightWallCollision()
		if (D1.s16 <= 0)
			result = true
	}
	
	popA456()
	
	return result
}

function void Character.LandingOnGroundResetState()
{
	if (!isECFCharA0("ECC-Mighty"))
	{
		base.Character.LandingOnGroundResetState()
		return
	}
	
	char.flags &= ~char.flag.IN_AIR
	char.flags &= ~char.flag.PUSHING
	char.flags &= ~char.flag.CONTROL_LOCK
	char.jumping = 0
	score.bonus_counter = 0		// No more increasing bonusses after hitting the ground
	char.rotation.x = 0
	u8[A0 + 0x2d] = 0
	u8[A0 + 0x30] = 0
	char.look_up_down_timer = 0

	// Check for double jump state
	if (char.double_jump_state != 0)
	{
		if (char.double_jump_state == 1)
		{
			if (MightyInteraction_cancelLand())
			{
				char.double_jump_state = 0
				char.state = char.state.MIGHTY_HAMMERDROP
			}
			else if (char.base_state == 2)
				MightyHammerDropBounce()
			else
				char.double_jump_state = 0
		}
		else
		{
			char.double_jump_state = 0
		}
	}

	// mostly unnecessary, but here as a safety catch, similar to vanilla Knuckles.
	if (char.state == char.state.MIGHTY_WALLCLING || char.state == char.state.MIGHTY_UNSPIN)
		char.state = char.state.RUNNING
	
#if LEMONS_TWEAKS_ACTIVE
	u32 A1_o = A1
	A1 = 0xffff0000 + char.object_standing_on
	if (MightyInteraction_getType() && char.flags & char.flag.ON_OBJECT && char.state.former == char.state.ROLLING && char.invuln.countdown == 0)
		char.state = char.state.ROLLING
	A1 = A1_o
#endif
}

function bool MightyInteraction_cancelLand()
{
	bool result = false
	u32 A1_o = A1
	A1 = 0xffff0000 + u32(char.object_standing_on)
		
	if (char.flags & char.flag.ON_OBJECT && char.object_standing_on)
	{
		// not entirely necessary in most cases here, but felt fitting to exclude them.
		
		// spikes and harmful floors
		if ((char.bonus_effect & char.bonus.INVINCIBLE) == 0 && char.invuln.countdown == 0 && (objA1.update_address == 0x024090 || objA1.update_address == 0x01f4c4))
			result = true
		// springs
		else if (objA1.update_address == 0x022ef4 || objA1.update_address == 0x023490)
			result = true
		// breakable floors
		else if (objA1.update_address == 0x01faf2 && objA1.subtype2c & 0x01 || objA1.update_address == 0x02a502 || objA1.update_address == 0x04172e || objA1.update_address == 0x08b384)
			result = true
		// hcz spinning pillar
		else if (objA1.update_address == 0x0326b6)
			result = true
		// cnz barrel
		else if (objA1.update_address == 0x032188)
			result = true
		// cnz cannon
		else if (objA1.update_address == 0x0318f2)
			result = true
		// ssz shell platform
		else if (objA1.update_address == 0x0462b6)
			result = true
	}
	
	A1 = A1_o
	
	return result
}

#if !LEMONS_TWEAKS_ACTIVE
//# address-hook(0x011eec) end(0x011fd4)
//# translated(0x012012) end(0x01209c)
//# translated(0x01209e) end(0x012100)
//# translated(0x012102) end(0x012170)
//# address-hook(0x0153c2) end(0x01560a)
function void Character.CheckCollision()
{
	if (!isECFCharA0("ECC-Mighty") || char.double_jump_state != 1)
	{
		base.Character.CheckCollision()
		return
	}
	
	// reorders two landing calls to be done after velocities are set.
#if STANDALONE
	if (A0 == 0xffffb000)
	{
		// Needed only for bubble shield bounce
		mainchar.groundhit.velocity.x = char.velocity.x
		mainchar.groundhit.velocity.y = char.velocity.y
	}
#endif

	bool someFlag = (char.character == CHARACTER_TAILS) ? level.HCZ_water_current_flags.tails : level.HCZ_water_current_flags.player1

	u32[0xfffff796] = (char.layer_flags1 == 0x0c) ? u32[0xfffff7b4] : u32[0xfffff7b8]

	D5.u8 = char.layer_flags2
	D0.u16 = lookupAngleByVector(char.velocity.x, char.velocity.y)
	D0.u8 = (D0.u8 - 0x20) & 0xc0
	if (D0.u8 == 0)
	{
		Character.CheckLeftWallCollision()
		if (D1.s16 < 0)
		{
			char.position.x.u16 -= D1.u16
			char.velocity.x = 0
		}

		Character.CheckRightWallCollision()
		if (D1.s16 < 0)
		{
			char.position.x.u16 += D1.u16
			char.velocity.x = 0
		}

		Character.CheckFloorCollision()
		if (D1.s16 < 0)
		{
			D2.u8 = (char.velocity.y >> 8) + 8
			D2.s8 = -D2.s8
			if (D0.s8 < D2.s8 && D1.s8 < D2.s8)
				return

			char.rotation = D3.u8
			char.position.y.u16 += global.inv_gravity ? -D1.s16 : D1.s16

			if (((D3.u8 + 0x20) & 0x40) == 0)
			{
				if (((D3.u8 + 0x10) & 0x20) == 0)
				{
					char.velocity.y = 0
					char.groundspeed = char.velocity.x
					Character.LandingOnGround()
					return
				}
				else
				{
					char.velocity.y >>= 1
				}
			}
			else
			{
				char.velocity.x = 0
				char.velocity.y = min(char.velocity.y, 0x0fc0)
			}

			char.groundspeed = char.velocity.y
			if (D3.s8 < 0)
			{
				char.groundspeed = -char.groundspeed
			}
			
			Character.LandingOnGround() // reordered
		}
	}
	else if (D0.u8 == 0x40)
	{
		Character.CheckLeftWallCollision()
		if (D1.s16 < 0)
		{
			char.position.x.u16 -= D1.u16
			char.velocity.x = 0
			char.groundspeed = char.velocity.y
		}

		Character.CheckCeilingCollision()
		if (D1.s16 < 0)
		{
			D1.s16 = -D1.s16
			if (D1.s16 < 0x14)
			{
				if (global.inv_gravity)
					D1.s16 = -D1.s16

				char.position.y.u16 += D1.u16
				char.velocity.y = max(char.velocity.y, 0)
			}
			else
			{
				Character.CheckRightWallCollision()
				if (D1.s16 < 0)
				{
					char.position.x.u16 += D1.u16
					char.velocity.x = 0
				}
			}
		}
		else
		{
			if (someFlag || char.velocity.y >= 0)
			{
				Character.CheckFloorCollision()
				if (D1.s16 < 0)
				{
					char.position.y.u16 += global.inv_gravity ? -D1.s16 : D1.s16
					char.rotation = D3.u8
					char.velocity.y = 0
					char.groundspeed = char.velocity.x
					Character.LandingOnGround()
				}
			}
		}
	}
	else if (D0.u8 == 0x80)
	{
		Character.CheckLeftWallCollision()
		if (D1.s16 < 0)
		{
			char.position.x.u16 -= D1.u16
			char.velocity.x = 0
		}

		Character.CheckRightWallCollision()
		if (D1.s16 < 0)
		{
			char.position.x.u16 += D1.u16
			char.velocity.x = 0
		}

		Character.CheckCeilingCollision()
		if (D1.s16 < 0)
		{
			if (global.inv_gravity)
				D1.s16 = -D1.s16

			char.position.y.u16 -= D1.u16
			if (((D3.u8 + 0x20) & 0x40) == 0)
			{
				char.velocity.y = 0
			}
			else
			{
				char.rotation = D3.u8

				char.groundspeed = char.velocity.y
				if (D3.s8 < 0)
					char.groundspeed = -char.groundspeed
				
				Character.LandingOnGround() // reordered
			}
		}
	}
	else	// (D0.u8 == 0xc0)
	{
		Character.CheckRightWallCollision()
		if (D1.s16 < 0)
		{
			char.position.x.u16 += D1.s16
			char.velocity.x = 0
			char.groundspeed = char.velocity.y
		}

		Character.CheckCeilingCollision()
		if (D1.s16 < 0)
		{
			char.position.y.u16 -= global.inv_gravity ? -D1.s16 : D1.s16
			char.velocity.y = max(char.velocity.y, 0)
		}
		else
		{
			if (someFlag || char.velocity.y >= 0)
			{
				Character.CheckFloorCollision()
				if (D1.s16 < 0)
				{
					char.position.y.u16 += global.inv_gravity ? -D1.s16 : D1.s16
					char.rotation = D3.u8
					char.velocity.y = 0
					char.groundspeed = char.velocity.x
					Character.LandingOnGround()
				}
			}
		}
	}
}
#endif

function void MightyHammerDropBounce()
{
	u8 input_state     = Character.getControlVariable(0)
	
	u16 gravityStrength = (char.flags & char.flag.UNDERWATER) ? 0x10 : 0x38
	u32 dropForce = gravityStrength + (char.flags & char.flag.UNDERWATER ? 0x100 : 0x200)
	u32 groundVel = char.groundspeed - (char.groundspeed >> 2)
	
	// Mania's Hammer Drop bounce formula!
	char.velocity.x = (groundVel * lookupCos(char.rotation) + dropForce * lookupSin(char.rotation)) >> 8
	char.velocity.y = (groundVel * lookupSin(char.rotation) - dropForce * lookupCos(char.rotation)) >> 8
	
	// new additions to make this move feel a little better!
	bool counteractive = (input_state & CONTROL_LEFT && char.velocity.x > 0 || input_state & CONTROL_RIGHT && char.velocity.x < 0)
	// drop-roll
	if (s8(char.rotation) < -0x10 || s8(char.rotation) >= 0x10) && (input_state & CONTROL_DOWN && !counteractive)
		char.groundspeed += groundVel >> 8
	else
	{
		if (char.velocity.y >= 0 && !counteractive)
			char.velocity.x = Math.roundToInt(char.velocity.x * 1.5)

		char.flags |= char.flag.IN_AIR
	}

	char.double_jump_state = 0
	char.state = char.state.ROLLING
	char.flags |= char.flag.ROLLING
	char.flags &= ~char.flag.PUSHING
	char.on_convex_surface = 0

	s8 dy = char.hitbox.y.ROLLING - char.hitbox_extends.y
	char.position.y.u16 += (global.inv_gravity) ? dy : -dy
	char.hitbox_extends.x = char.hitbox.x.ROLLING
	char.hitbox_extends.y = char.hitbox.y.ROLLING
	
	push(A1)
	for (u8 i; i < 6; ++i)
	{
		s16 vel = 0x100 + 0x80 * (i / 2)
		if ((i % 2) == 0)
			vel *= -1
		if (char.flags & char.flag.IN_AIR)
			vel *= -1
			
		if (!Mighty_spawnDust(vel))
			break
	}
	A1 = pop()
	
	camera.hyper_knux_shake = 0x0114
	Audio.playOverride((ecc_setting_mightyManiaSounds) ? "mighty_land" : "mighty_c_land", AudioContext.CONTEXT_SOUND, Character.getCharAudioChannelA(), 1)
	
	u8 pId = ((A0.u16 - 0xb000) / 0x4a) + 1
	setPlayerGlobalValue("mighty_shockwave_t", 2)
	setPlayerGlobalValue("mighty_shockwave_x", objA0.position.x.u16)
	setPlayerGlobalValue("mighty_shockwave_y", objA0.position.y.u16)
	
	setPlayerGlobalValue("mighty_cam_vlock", 0)
	
	if (Character.getSuperState() & 0x80)
		Character.ClearEnemiesOnScreen()
	Input.setControllerRumbleByAddress(A0, 0.5f, 1.0f, 200)
}

//# address-hook(0x011036) end(0x01105e)
function void Character.UpdateSonicRollingInAir()
{
	if (!isECFCharA0("ECC-Mighty"))
	{
		base.Character.UpdateSonicRollingInAir()
		return
	}
	
	u8 input_state     = Character.getControlVariable(0)
	u8 input_pressed   = Character.getControlVariable(1)
	
	u8 inputForward = (char.flags & char.flag.FACING_LEFT) ? CONTROL_LEFT : CONTROL_RIGHT
	u8 inputBackward = (char.flags & char.flag.FACING_LEFT) ? CONTROL_RIGHT : CONTROL_LEFT
	
	s16 power = (char.flags & char.flag.UNDERWATER) ? 0x700 : 0xa00
	
	u8 slideMin = 15
	u8 slideMax = 30
	u8 maxTime = 90
	
	// Wall Cling!
	if (char.double_jump_state == 2)
	{
		u8 clingtime = getPlayerGlobalValue("mighty_cling_timer")
		if (clingtime >= slideMax)
			power = Math.roundToInt(0.8 * power)
		
		bool jumpCond = (!ecc_setting_mightyWallJumpControls) ? ((input_state & CONTROL_ABC) == 0) : (input_pressed & CONTROL_ABC)
		// holding too long or mighty isnt touching a wall? exit cling state and enter a roll
		if (clingtime > maxTime || !Character_checkWallInFront())
		{
			char.double_jump_state = 0
			char.jumping = 0
			char.state = char.state.ROLLING
			base.Character.UpdateSonicRollingInAir()
			return
		}
		else if (jumpCond)
		{
			// no input = go backwards
			if ((input_state & CONTROL_DPAD) == 0)
				input_state |= inputBackward
			// holding forward = back and up
			else if (input_state & inputForward && (input_state & CONTROL_UP) == 0 && (input_state & CONTROL_DOWN) == 0)
			{
				input_state &= ~inputForward
				input_state |= (inputBackward | CONTROL_UP)
			}
			// random tidbit: in chaotix, holding down forward will result in mighty jumping up backwards
			/*else if (input_state & inputForward && input_state & CONTROL_DOWN)
			{
				input_state &= ~(inputForward | CONTROL_DOWN)
				input_state |= (inputBackward | CONTROL_UP)
			}*/
			else
				input_state &= ~inputForward
				
			u8 angle = 0

			u8 add = (input_state & CONTROL_LEFT || input_state & CONTROL_RIGHT) ? 0x20 : 0x40
			if (input_state & CONTROL_DOWN)
				angle += add
			else if (input_state & CONTROL_UP)
				angle -= add
			
			if (input_state & CONTROL_DPAD)
			{
				char.velocity.x = (s32(lookupCos(angle)) * ((char.flags & char.flag.FACING_LEFT) ? power : -power)) >> 8
				char.velocity.y = (s32(lookupSin(angle)) * power) >> 8
			}
			
			//debugLog(stringformat((char.velocity.x < 0) ? ((char.velocity.y < 0) ? "-%x, -%x" : "-%x, %x") : (char.velocity.y < 0) ? "%x, -%x" : "%x, %x", abs(char.velocity.x), abs(char.velocity.y)))
			
			char.state = (char.velocity.x != 0) ? char.state.MIGHTY_WALLJUMP : char.state.ROLLING
			char.double_jump_state = 0
			playSound(SFX_JUMP)
			char.jumping = 2
			
			Character.CheckAgainstMoveBorders()
			
			Character.UpdateRotationInAir()
			Character.CheckCollision()
			return
		}

		UpdateSonicJumpMoves()
		//Character.UpdateControlInAir()
		Character.CheckAgainstMoveBorders()
		UpdateMovementStraight()
		
		// mostly to warn you that you've been holding on too long... 
		// looks cool though, so also spawn it when moving up.
		if (clingtime >= slideMin || char.velocity.y < 0)
		{
			s8 countdown = getPlayerGlobalValue("mighty_cling_dustcountdown")
			
			--countdown
			if (countdown < 0)
			{
				Mighty_spawnDustWall()
				playSound(0x7e)
				if (char.velocity.y < 0)
					countdown = max((0x800 + char.velocity.y) / 0x80, 2)
				else
					countdown = max((maxTime - clingtime) / 3, 2)
			}
			
			setPlayerGlobalValue("mighty_cling_dustcountdown", countdown)
		}
		else
			setPlayerGlobalValue("mighty_cling_dustcountdown", 0)
		
		// Mighty can slide up a little bit... as a treat.
		if (char.velocity.y < 0 && clingtime == 0)
		{
			s16 grav = ((char.flags & char.flag.UNDERWATER) ? 0x10 : 0x38) 
			//grav += Math.roundToInt(grav * (clingtime / 5.0))
			if ((input_state & CONTROL_DOWN) == 0)
				grav /= 2
			char.velocity.y += grav
		}
		else
		{
			if (clingtime > slideMin)
				char.velocity.y += Math.roundToInt(min(1.0 * (clingtime - slideMin) / slideMax, 1) * 1.0 * ((char.flags & char.flag.UNDERWATER) ? 0x10 : 0x38) / 5.0)
			++clingtime
			setPlayerGlobalValue("mighty_cling_timer", clingtime)
		}

		Character.UpdateRotationInAir()
		Character.CheckCollision()
	}
	else
	{
		UpdateSonicJumpMoves()
		Character.UpdateControlInAir()
		Character.CheckAgainstMoveBorders()
		if (char.state == char.state.MIGHTY_WALLCLING)
			UpdateMovementStraight()
		else
		{
			Character.UpdateMovement()

			if (char.flags & char.flag.UNDERWATER)
			{
				// Gravity
				char.velocity.y -= 0x28
			}
		}
		Character.UpdateRotationInAir()
		Character.CheckCollision()
	}
}

//# address-hook(0x01164e) end(0x0116dc)
//# address-hook(0x014e78) end(0x014f06)
//# address-hook(0x017680) end(0x01770e)
function void Character.UpdateControlInAir()
{
	if (!isECFCharA0("ECC-Mighty") || char.state != char.state.MIGHTY_WALLJUMP)
	{
		base.Character.UpdateControlInAir()
		return
	}
	
	// Mighty's wall jump animation stops him from turning... it just looked kinda weird.
	
	u8 input_state = Character.getControlVariable(0)
	s16 vx = char.velocity.x

	// Direct control
	if ((char.flags & char.flag.CONTROL_LOCK) == 0)
	{
		s16 maxSpeed = s16[A4]
		s16 acceleration = s16[A4 + 2] * 2

		if (input_state & CONTROL_LEFT)
		{
			vx -= acceleration
			if (vx <= -maxSpeed)
			{
				vx += acceleration
				vx = min(vx, -maxSpeed)
			}
		}
		if (input_state & CONTROL_RIGHT)
		{
			vx += acceleration
			if (vx >= maxSpeed)
			{
				vx -= acceleration
				vx = max(vx, maxSpeed)
			}
		}
	}

	// Center camera y-offset again
	centerCameraYOffset()

	// Air drag
	if (char.velocity.y < 0 && char.velocity.y >= -0x400)  // Not when falling or going up too fast
	{
		s16 drag = vx >> 5		// Do not divide here, as it rounds differently for negative numbers
		if (drag != 0)
		{
			vx -= drag
			if (drag > 0)
				vx = max(vx, 0)
			else
				vx = min(vx, 0)
		}
	}

	char.velocity.x = vx
}

//# address-hook(0x00ff06) end(0x00ff5e)
function void Character.CheckCollisionsWithDynamicObjects_partial()
{
	if (!isECFCharA0("ECC-Mighty") || getPlayerGlobalValue("mighty_shockwave_t") == 0)
	{
		base.Character.CheckCollisionsWithDynamicObjects_partial()
		return
	}

	s16 waveX = getPlayerGlobalValue("mighty_shockwave_x")
	s16 waveY = getPlayerGlobalValue("mighty_shockwave_y")
	
#if LEMONS_TWEAKS_ACTIVE
	if (set_lt_fixedHitboxes)
	{
		u8 quart = getRotationQuarter(char.rotation)
		s16 x = D2.s16 - s16(char.position.x.u16)
		s16 y = D3.s16 - s16(char.position.y.u16)
		s16 w = D4.s16
		s16 h = D5.s16
		
		if (quart == 0xc0)
		{
			D2.u16 = char.position.x.u16 + y
			D3.u16 = char.position.y.u16 - w - x
			D4.u16 = h
			D5.u16 = w
		}
		else if (quart == 0x80)
		{
			D2.u16 = char.position.x.u16 - w - x
			D3.u16 = char.position.y.u16 - h - y
		}
		else if (quart == 0x40)
		{
			D2.u16 = char.position.x.u16 - h - y
			D3.u16 = char.position.y.u16 + x
			D4.u16 = h
			D5.u16 = w
		}
	}
	
	// Bounding box of player
	if (debugDrawFlag == 2)
	{
		Renderer.drawRect(D2.u16, D3.u16, D4.u16, D5.u16, 0x00ff0080, 0xfff5, true)
		u16 a = System.getGlobalVariableValueByName(stringformat("p%d_hbox_x", (A0.u16 - 0xb000) / 0x4a + 1))
		u16 b = System.getGlobalVariableValueByName(stringformat("p%d_hbox_y", (A0.u16 - 0xb000) / 0x4a + 1))
		u16 c = System.getGlobalVariableValueByName(stringformat("p%d_hbox_h", (A0.u16 - 0xb000) / 0x4a + 1))
		u16 d = System.getGlobalVariableValueByName(stringformat("p%d_hbox_w", (A0.u16 - 0xb000) / 0x4a + 1))
		if (D2.u16 != a || D3.u16 != b || D4.u16 != c || D5.u16 != d)
			Renderer.drawRect(a, b, c, d, 0xff00ffa0, 0xfff0, true)
			
		Renderer.drawRect(waveX- 48, waveY, 96, char.hitbox.y.ROLLING + 16, 0x00ff0080, 0xfff5, true)
	}
	
	bool extraInstance
#else 
	// Bounding box of player
	if (DEBUG_DYNAMIC_COLLISIONS)
		debugDrawRect(D2.u16, D3.u16, D4.u16, D5.u16, 0x8000ff00)
#endif

	u16 numObjects = global.dynamic_objects.size		// Actually it's twice the number of dynamic objects
	A4 = addressof(global.dynamic_objects.size) + 2		// Resulting address: 0xffffe382
	while (numObjects != 0)
	{
		// Get address of dynamic object
		A1 = 0xffff0000 + u16[A4]
		A4 += 2

		// Offset into a list of hitbox sizes (the list looks a bit random)
		u16 offset = objA1.collision_attributes
		if (offset != 0)
		{
			A2 = 0x00ff62 + (offset & collision_attributes.size) * 2
			s16 hitbox.x = u8[A2]
			s16 hitbox.y = u8[A2+1]

			u16 px = objA1.position.x.u16 - hitbox.x
			u16 py = objA1.position.y.u16 - hitbox.y
			u16 sx = hitbox.x * 2
			u16 sy = hitbox.y * 2

		#if LEMONS_TWEAKS_ACTIVE
			if (debugDrawFlag == 2)
		#elif STANDALONE
			if (DEBUG_DYNAMIC_COLLISIONS)
		#endif
			{
				if ((offset & collision_attributes.flags) == collision.flag.ITEM)
					debugDrawRect(px, py, sx, sy, 0x8000ff00)
				else if ((offset & collision_attributes.flags) == collision.flag.SPECIAL)
					debugDrawRect(px, py, sx, sy, 0x80ff0000)
				else if ((offset & collision_attributes.flags) == collision.flag.THREAT)
					debugDrawRect(px, py, sx, sy, 0x800000ff)
				else
					debugDrawRect(px, py, sx, sy, 0x80ff00ff)
			}

			if (checkBoxOverlap(D2.u16, D3.u16, D4.u16, D5.u16, px, py, sx, sy))
			{
			#if LEMONS_TWEAKS_ACTIVE
				s16 oldVX = char.velocity.x
				s16 oldVY = char.velocity.y
				
				bool boss = false
				if ((offset & collision_attributes.flags) == collision.flag.DESTRUCTIBLE)
					boss = (u8[A1 + 0x29] != 0)
					
				// Collision found
				bool ignore 
				if ((offset & collision_attributes.flags) == collision.flag.THREAT)
				{
					ignore = (u32[0xffff0000 + u32(u16[A1 + 0x46])] == addressof(SmallExplosion.BaseUpdate))
				}
				
				if (!ignore)
				{
					Character.OnCollisionWithDynamicObject()
					
					if (extraInstance)
					{
						if (char.velocity.x == -oldVX)
							char.velocity.x = oldVX
						if (char.velocity.y == -oldVY)
							char.velocity.y = oldVY
					}
					else
						extraInstance = true
				}
				
				if (char.base_state != 2 || boss)
					return
			#else
				// Collision found
				Character.OnCollisionWithDynamicObject()
				return
			#endif
			}
			// shockwave
			else if ((offset & collision_attributes.flags) == collision.flag.DESTRUCTIBLE || (offset & collision_attributes.flags) == collision.flag.ITEM && (offset & collision_attributes.size) == collision.size.16x16) && (checkBoxOverlap(waveX - 48, waveY, 96, char.hitbox.y.ROLLING + 16, px, py, sx, sy))
			{
				if ((offset & collision_attributes.flags) == collision.flag.DESTRUCTIBLE)
				{
					if (u8[A1 + 0x29] != 0)
					{
						u8[A1 + 0x1c] = A0.u8
						u8[A1 + 0x25] = u8[A1 + 0x28]
						u8[A1 + 0x28] = 0
						--u8[A1 + 0x29]
						if (u8[A1 + 0x29] == 0)
						{
							u8[A1 + 0x2a] |= 0x80
						}
					}
					else
					{
						if (u8[A1 + 0x2a] & 0x04)
						{
							A2 = 0xffff0000 + u16[A1 + 0x3c]
							u8[A2] &= ~(1 << u8[A1 + 0x3b])
						}

						u8[A1 + 0x2a] |= 0x80

						// Grant bonus points
						Enemy.addScore(A1, 0x010216)

						objA1.update_address = addressof(SmallExplosion.BaseUpdate)
						u8[A1 + 0x05] = 0
					}
				}
				else
				{
					objA1.base_state = 0x04		// Set monitor state to broken
					objA1.monitor.character_address = A0.u16		// RAM address of character
				}
			#if LEMONS_TWEAKS_ACTIVE
				extraInstance = true
			#else
				return
			#endif
			}
		}

		numObjects -= 2
	}
	
	Character.MightyShockwaveExtraCollision(waveX, waveY)
}

function void Character.MightyShockwaveExtraCollision(s16 waveX, s16 waveY)
{
	// all this does is check for mines... so not really worth much
	if (global.zone != 0x4)
		return
	
	for (A1 = 0xffffb128; A1 < 0xffffcb2c; A1 += 0x4a)
	{
		if (objA1.update_address == 0x03c972)
		{
			u16 px = objA1.position.x.u16 - objA1.box_size.x
			u16 py = objA1.position.y.u16 - objA1.box_size.y
			u16 sx = objA1.box_size.x * 2
			u16 sy = objA1.box_size.y * 2
			
			if (debugDrawFlag == 2)
				debugDrawRect(px, py, sx, sy, 0x800080ff)
			
			if (checkBoxOverlap(waveX - 48, waveY, 96, char.hitbox.y.ROLLING + 16, px, py, sx, sy))
				objA1.update_address = 0x03c9bc
		}
	}
}

function void Character.OnHitBoss()
{
	if (isECFCharA0("ECC-Mighty") && char.state == char.state.MIGHTY_HAMMERDROP)
	{
		char.double_jump_state = 2
		char.state = char.state.ROLLING
		char.velocity.y = (char.flags & char.flag.UNDERWATER) ? -0x100 : -0x200
	}
	else
		base.Character.OnHitBoss()
}

function void Character.OnHitBadnik()
{
	if (!isECFCharA0("ECC-Mighty") || char.state != char.state.MIGHTY_HAMMERDROP)
		base.Character.OnHitBadnik()
}

function void Character.OnHitMonitor()
{
	if (!isECFCharA0("ECC-Mighty") || char.state != char.state.MIGHTY_HAMMERDROP)
		base.Character.OnHitMonitor()
}

//# address-hook(0x085732) end(0x08575e)
function void fn085732()
{
	if (!isECFCharAt(u32(0xffff0000 + u16[A0 + 0x44]), "ECC-Mighty"))
	{
		base.fn085732()
		return
	}
	
	fn085760()
		
	A1 = 0xffff0000 + u16[A0 + 0x44]
	if (objA1.state == char.state.MIGHTY_HAMMERDROP)
		return
		
	if (objA1.velocity.y < 0)
	{
		objA1.velocity.y += 0x0100
	}
	else if (objA1.position.y.u16 >= objA0.position.y.u16)
	{
		objA1.velocity.y -= 0x0100
	}
	else
	{
		objA1.velocity.y = -objA1.velocity.y
	}
}