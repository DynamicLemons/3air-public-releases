// this is mostly just removing character specific behavior from base cast and accounting for new functions.

// follow object
function void Character.Initialization.shared(u8 character)
{
	if (getECFCharBufferName(A0) == 0 || ECF_disableBranchBase)
	{
		base.Character.Initialization.shared(character)
		return
	}
	
	// untouched mostly, but follow object behavior has been replaced.
	char.base_state += 2

	char.character = character

	u8 characterHeight = (character == CHARACTER_TAILS) ? char.hitbox.y.UPRIGHT_TAILS : char.hitbox.y.UPRIGHT
	char.hitbox_extends.x = char.hitbox.x.UPRIGHT
	char.hitbox_extends.y = characterHeight
	char.hitbox.default.x = char.hitbox.x.UPRIGHT
	char.hitbox.default.y = characterHeight

	if (character == CHARACTER_SONIC)
	{
		char.mapping_offset = 0x146620
	}
	else if (character == CHARACTER_TAILS)
	{
		char.mapping_offset = 0x148eb8
	}
	else  // if (character == CHARACTER_KNUCKLES)
	{
		char.mapping_offset = 0x14a8d6
	}

	char.sprite_priority = 0x100
	char.box_size.x = 0x18
	char.box_size.y = 0x18
	char.render_flags = render_flag.WORLD
	if (character == CHARACTER_TAILS)
		char.render_flags |= render_flag.VISIBLE

	setSpeedCapProperties(A4, false)

	char.rotation.x.count = 0
	char.rotation.x.speed = 4
	char.drown_countdown = 30

	if (character == CHARACTER_TAILS)
	{
		if (isMainCharacter(CHARACTER_TAILS))
		{
			if (checkpoint.number == 0)
			{
				char.sprite_attributes = (Char.Tails.targetInVRAM >> 5)
				char.layer_flags1 = 0x0c
				char.layer_flags2 = 0x0d

				if (global.stage_type != 2)
				{
					checkpoint.x = char.position.x.u16
					checkpoint.y = char.position.y.u16
					checkpoint.sprite_attr = char.sprite_attributes
					checkpoint.layer_flags = char.layer_flags
				}
			}
		}
		else
		{
			char.sprite_attributes = (Char.Tails.targetInVRAM >> 5) | (u16[0xffffb000 + 0x0a] & sprite_attribute.PRIORITY)
			char.layer_flags = u16[0xffffb000 + 0x46]
		}

		super.active.tails = 0

		if (tails.ai_routine != 0x12 && tails.ai_routine != 0x20)
			tails.ai_routine = 0

		tails.control_counter = 0
		tails.respawn_counter = 0

		checkpoint.number.backup.tails = checkpoint.number
	}
	else
	{
		if (checkpoint.number == 0)
		{
			char.sprite_attributes = (Char.Player1.targetInVRAM >> 5)
			char.layer_flags1 = 0x0c
			char.layer_flags2 = 0x0d

			if (global.stage_type != 2)
			{
				checkpoint.x = char.position.x.u16
				checkpoint.y = char.position.y.u16
				checkpoint.sprite_attr = char.sprite_attributes
				checkpoint.layer_flags = char.layer_flags
			}
		}

		super.active = 0

		char.position.x.u16 -= 0x20
		char.position.y.u16 += 4
		ClearPositionBackup()
		char.position.x.u16 += 0x20
		char.position.y.u16 -= 4
	}
	
	u32 obj = ECF_getFollowInitRoutine(getECFCharBufferName())
	if (obj != 0)
	{
		u32[0xffffcc0a] = obj
		u16[0xffffcc0a + 0x30] = A0.u16
	}
}

// remove c-abilities
//# address-hook(0x010bba) end(0x010c8e)
function void Character.UpdateNormalState.Sonic()
{
	if (getECFCharBufferName(A0) == 0 || ECF_disableBranchBase)
	{
		base.Character.UpdateNormalState.Sonic()
		return
	}
	
	if (updateDebugModeInput(false))
		return

	if (player1.control_override == 0)
	{
		// Set player 1 control state
		control.player1 = control.pad1
	}

	if (char.control_flags & control_flag.DISABLE_UPDATE)
	{
		// Character is not directly controllable (but may be indirectly via an object, like when hanging on a pole or similar)
		char.double_jump_state = 0
	}
	else
	{
		// Call update function depending on flags
		pushA456()
		// Targets:
		//  - 0x010f2c	-> (char.flags & (char.flag.IN_AIR | char.flag.ROLLING)) = 0x00										-> Character.UpdateSonicUprightOnGround()
		//  - 0x010fb6	-> (char.flags & (char.flag.IN_AIR | char.flag.ROLLING)) = char.flag.IN_AIR							-> Character.UpdateSonicUprightInAir()
		//  - 0x010fe0	-> (char.flags & (char.flag.IN_AIR | char.flag.ROLLING)) = char.flag.ROLLING						-> Character.UpdateSonicRollingOnGround()
		//  - 0x011036	-> (char.flags & (char.flag.IN_AIR | char.flag.ROLLING)) = (char.flag.IN_AIR | char.flag.ROLLING)	-> Character.UpdateSonicRollingInAir()
		call tableLookupAddress(0x010c90, char.flags & (char.flag.IN_AIR | char.flag.ROLLING))
		popA456()
	}

#if STANDALONE
	if (Game.getSetting(SETTING_SUPERFAST_RUNANIM) && !super.active && abs(char.groundspeed) >= 0x0d00)
	{
		sonic.fastrunanim.timer = 30
	}
	else if (sonic.fastrunanim.timer > 0)
	{
		if (abs(char.groundspeed) >= 0x0800)
			--sonic.fastrunanim.timer
		else
			sonic.fastrunanim.timer = 0
	}
#endif

	if (level.vertical_wrap == 0xff00)
	{
		char.position.y.u16 &= level.height.bitmask
	}

	Character.updateBonusEffects()
	Character.UpdateRingsInSuperForm()
	Character.WriteToPositionBackup()
	Character.checkForWaterSurface()

	char.angle_sensor_1 = u8[0xfffff768]
	char.angle_sensor_2 = u8[0xfffff76a]

	if (level.HCZ_water_current_flags.player1 != 0)
	{
		if (char.state == char.state.RUNNING)
			char.state = char.state.former
	}

	if ((char.control_flags & control_flag.DISABLE_ANIMATION) == 0)	// Hanging flag
	{
		UpdateSonicAnimation()
		if (global.inv_gravity)
		{
			char.render_flags ^= render_flag.FLIP_Y
		}
		UpdateSonicSpritePatterns()
	}

	if ((char.control_flags & (control_flag.DISABLE_INTERACTION | 0x20)) == 0)
	{
		Character.CheckCollisionsWithDynamicObjects()
	}
}

function void Character.updateUprightOnGround()
{
	if (getECFCharBufferName(A0) == 0 || ECF_disableBranchBase)
	{
		base.Character.updateUprightOnGround()
		return
	}
	
	if (char.character == CHARACTER_TAILS)
		Tails.CheckDropSonic()

	if (Character.UpdateSpindash())
		return

	if (Character.CheckStartJump())
		return

	Character.UpdateUprightSlopeEffect()
	Character.updateUprightOnGroundInner()
	Character.CheckForStartRolling()

	Character.sharedUpdateOnGround()
}


function void Character.updateJumpMoves()
{
	if (getECFCharBufferName(A0) == 0 || ECF_disableBranchBase)
	{
		base.Character.updateJumpMoves()
		return
	}
	
	u8 input_state     = Character.getControlVariable(0)
	u8 input_pressed   = Character.getControlVariable(1)
	bool isSuperActive = (char.character == CHARACTER_TAILS) ? super.active.tails    : super.active

	if (char.jumping)
	{
		// Limit velocity.y
		s16 max_vy = (char.flags & char.flag.UNDERWATER) ? -0x200 : -0x400
		if (char.velocity.y < max_vy)
		{
			// Limit vertical velocity while not pressing any jump button
			//  -> This is important to support low jumps by just tapping the button briefly
			if ((input_state & CONTROL_ABC) == 0)
			{
				char.velocity.y = max_vy
			}
		}
		else
		{
			if (char.double_jump_state == 0)
			{
				#if STANDALONE
					if (Input.buttonPressed(BUTTON_Y))
					{
						if (!isSuperActive && char.invuln.countdown == 0)	// Check invulnerability to prevent spamming of super activate + cancel
						{
							if (Character.performSuperTransformation())
								return
						}
					}
				#endif

				// Check if pressed jump again in mid-air
				if (input_pressed & CONTROL_ABC)
				{
				#if STANDALONE
					// Check for other things to do instead of the usual reaction to jump button pressed
					if (onCharacterPressedJumpInMidAir(input_state, input_pressed))
				#endif
						ECFGenericPressedJumpInMidAir()
				}
			}
		}
	}
	else
	{
		if (char.spindash == 0)
		{
			char.velocity.y = max(char.velocity.y, -0x0fc0)
		}
	}
}

function void ECFGenericPressedJumpInMidAir()
{
	char.flags &= ~char.flag.CONTROL_LOCK
	char.double_jump_state = 1
}

//# address-hook(0x0147b8) end(0x014820)
function void Character.UpdateTailsUprightInAir()
{
	if (getECFCharBufferName(A0) && !ECF_disableBranchBase)
		updateTailsInAir_shared()
	else
		base.Character.UpdateTailsUprightInAir()
}

//# address-hook(0x01684c) end(0x01688e)
function void Character.UpdateKnucklesUprightInAir()
{
	if (getECFCharBufferName(A0) && !ECF_disableBranchBase)
		Character.UpdateKnucklesRollingInAir()
	else
		base.Character.UpdateKnucklesUprightInAir()
}

function void Character.LandingOnGroundResetState()
{
	if (getECFCharBufferName(A0) == 0)
	{
		base.Character.LandingOnGroundResetState()
		return
	}
	
	char.flags &= ~(char.flag.IN_AIR | char.flag.PUSHING | char.flag.CONTROL_LOCK)
	char.jumping = 0
	score.bonus_counter = 0		// No more increasing bonuses after hitting the ground
	char.rotation.x = 0
	char.flags2d = 0
	char.rotation.x.count = 0
	char.look_up_down_timer = 0
	char.double_jump_state = 0
}

//# address-hook(0x00fe8e) end(0x00ff04)
function void Character.CheckCollisionsWithDynamicObjects()
{
	if (getECFCharBufferName(A0) == 0 || ECF_disableBranchBase)
	{
		base.Character.CheckCollisionsWithDynamicObjects()
		return
	}
	
	SonicUpdateRingCollection()
	UpdateShieldDeflecting()

	D5 = char.hitbox_extends.y - 3
	D2 = char.position.x.u16 - 8
	D3 = char.position.y.u16 - D5.u16
	D4 = 16
	D5 *= 2
	Character.CheckCollisionsWithDynamicObjects_partial()
}

//# address-hook(0x01021e) end(0x010288)
function void Character.OnThreatCollision()
{
	if (getECFCharBufferName(A0) == 0 || ECF_disableBranchBase)
	{
		base.Character.OnThreatCollision()
		return
	}
	
	// Check for shield or invincibility
	D0.u8 = (char.bonus_effect & (char.bonus.ALL_SHIELDS | char.bonus.INVINCIBLE))
	if (D0.u8 != 0)
	{
		D0.u8 &= u8[A1 + 0x2b]
		if (D0.u8 != 0)
		{
			D0 = 0xffffffff
			return
		}

		if ((char.bonus_effect & char.bonus.ANY_SHIELD) == 0)
		{
			if ((char.bonus_effect & char.bonus.INVINCIBLE) == 0)
			{
				Character.OnThreatCollisionInner()
			}
			D0 = 0xffffffff
			return
		}
	}
	else
	{
		Character.OnThreatCollisionInner()
		return
	}

	if ((u8[A1 + 0x2b] & char.bonus.DEFLECTABLE) == 0)
	{
		if ((char.bonus_effect & char.bonus.INVINCIBLE) == 0)
		{
			Character.OnThreatCollisionInner()
		}
	}
	else
	{
		deflectProjectile()
	}
	D0 = 0xffffffff
}

//# address-hook(0x00ffd4) end(0x010214)
function void Character.OnCollisionWithDynamicObject()
{
	if (getECFCharBufferName(A0) == 0 || ECF_disableBranchBase)
	{
		base.Character.OnCollisionWithDynamicObject()
		return
	}
	
	// Example values for objA1.collision_attributes:
	//  - 0x06, 0x0b, 0x17, 0x1a = Different types of enemies
	//  - 0x0f		 = Boss enemy
	//  - 0x18		 = Extended arm of DEZ Chainspike
	//  - 0x23		 = AIZ Bloominator
	//  - 0x46		 = Monitor
	//  - 0x47		 = Dynamic ring
	//  - 0x87		 = Extended arm of SOZ Skorp
	//  - 0x8b, 0x9c = Flames, damaging parts of enemies
	//  - 0x8f		 = Wrecking ball
	//  - 0x98, 0x9b = Projectile
	//  - 0xd8		 = Thrown mushroom, stars over starpost

	D1.u8 = (objA1.collision_attributes & collision_attributes.flags)
	if (D1.u8 == 0)
	{
		// Collision is an enemy, i.e. is harmful, but can be attacked
		if (!ECF_isCharacterAttacking() && (char.bonus_effect & char.bonus.INVINCIBLE) == 0)
		{
			Character.OnThreatCollision()
			return
		}

		if (u8[A1 + 0x29] != 0)
		{
			u8[A1 + 0x1c] = A0.u8
			u8[A1 + 0x25] = u8[A1 + 0x28]
			u8[A1 + 0x28] = 0
			--u8[A1 + 0x29]
			if (u8[A1 + 0x29] == 0)
			{
				u8[A1 + 0x2a] |= 0x80
			}
			Character.OnHitBoss()
		}
		else
		{
			if (u8[A1 + 0x2a] & 0x04)
			{
				A2 = 0xffff0000 + u16[A1 + 0x3c]
				u8[A2] &= ~(1 << u8[A1 + 0x3b])
			}

			u8[A1 + 0x2a] |= 0x80

			// Grant bonus points
			Enemy.addScore(A1, 0x010216)

			objA1.update_address = addressof(SmallExplosion.BaseUpdate)
			u8[A1 + 0x05] = 0
			Character.OnHitBadnik()
		}
	}
	else if (D1.u8 == collision.flag.ITEM)
	{
		D0.u8 = (objA1.collision_attributes & collision_attributes.size)
		if (D0.u8 != collision.size.16x16)
		{
			// Collect ring, but only after 30 invulnerability frames
			//  -> Remember that the "char.invuln.countdown" timer starts at 120
			u8 timer = competition_mode.active ? char.invuln.countdown : u8[0xffffb000 + 0x34]
			if (timer < 90)
			{
				u8[A1 + 0x05] = 0x04
			}
		}
		else
		{
			// This part seems to be for monitors specifically
			s16 vy = (global.inv_gravity) ? -char.velocity.y : char.velocity.y
		#if STANDALONE
			// Calculate if the player is moving up, specifically relative to the monitor
			vy = char.velocity.y - objA1.velocity.y
		#endif
			bool movingUp = (objA1.render_flags & render_flag.FLIP_Y) ? (vy > 0) : (vy < 0)
		#if STANDALONE
			movingUp = (vy < 0)		// Velocity is normalised for inverted gravity anyway, so no need for fancy conditional checks

			// If player and monitor are at different orientations, check if player is moving down instead of up
			if ((objA1.render_flags & render_flag.FLIP_Y) != (char.render_flags & render_flag.FLIP_Y))
			{
				movingUp = !movingUp

				if (char.flags & char.flag.IN_AIR)
					objA1.flags2a &= ~object.flag.P1_PUSHING
			}

			movingUp = (movingUp && (abs(char.position.x.u16 - objA1.position.x.u16) < 0x12 || char.state == char.state.ROLLING))		// only bounce at a certain distance, otherwise push the player away when falling, #contributed by GFX32
		#endif
			if (movingUp)
			{
			#if STANDALONE
				if ((objA1.flags2a & object.flag.P1_PUSHING) && (char.flags & char.flag.IN_AIR))
				{
					// In S3AIR, do not allow S&K's monitor opening from the side
					//  -> This is done to be more consistent with other Sonic games, incl. Sonic 1, 2, CD, Mania and even Sonic 3 alone
					//  -> The first check above tells us if the character is on a side of the monitor
					//  -> The second one makes sure that you can always ground-based roll into a monitor (see e.g. first invincibility in MHZ 1, when spindashing into it from the right)
					return
				}
				else if (Game.getSetting(SETTING_MONITOR_BEHAVIOR) == 0)
				{
					// All you really need for Sonic & Knuckles monitor Behavior. everything else relevant is handled elsewhere
					char.velocity.y = -char.velocity.y
				}
				else
				{
					// Improved code to prevent crushing and allow bouncing on ground, #contributed by GFX32

					// If the player is below the monitor, it should bounce.
					bool isBelow = (char.position.y.u16 > (objA1.position.y.u16 + objA1.hitbox_extends.y))

					if (objA1.render_flags & render_flag.FLIP_Y)
						isBelow = (char.position.y.u16 < (objA1.position.y.u16 - objA1.hitbox_extends.y))

					// Not when spindashing!
					if (char.state == char.state.SPINDASH)
						isBelow = false

					if (isBelow)
					{
						// Hit monitor from below, make it fall
						u8[A1 + 0x3c] = 1

						char.velocity.y = -char.velocity.y
						objA1.velocity.y = -0x180

						// Calculate how far the monitor is inside the player, then separate them; this attempts to prevent crushing collision on subsequent frames.
						s16 dy = (objA1.position.y.u16 + objA1.hitbox_extends.y) - (char.position.y.u16 - char.hitbox_extends.y)

						if (objA1.render_flags & render_flag.FLIP_Y)
							dy = (objA1.position.y.u16 - objA1.hitbox_extends.y) - (char.position.y.u16 + char.hitbox_extends.y)

						// Only push the player when in midair
						if (char.flags & char.flag.IN_AIR)
						{
							dy /= 2
							char.position.y.u16 += dy
						}
						objA1.position.y.u16 -= dy

						if (u8[A1 + 0x3c] == 0)
							u8[A1 + 0x3c] = 4

						return
					}
				}
			#else
				if (objA1.flags2a & char.flag.IN_AIR)
				{
					// This block is a bit broken due to the above check, and falling monitors can crush the player, and is this really what we want?

					if ((objA1.render_flags & render_flag.FLIP_Y) == 0)
					{
						if (char.position.y.u16 - 0x10 < objA1.position.y.u16)
							return
					}
					else
					{
						if (char.position.y.u16 + 0x10 >= objA1.position.y.u16)
							return
					}

					char.velocity.y = -char.velocity.y
					objA1.velocity.y = -0x180
					if (u8[A1 + 0x3c] == 0)
						u8[A1 + 0x3c] = 4

					return
				}
			#endif
			}

			if (A0 != 0xffffb000 && competition_mode.active == 0)
			{
				// Sorry player 2, you can't open monitors in normal game
				return
			}

			bool canOpenMonitor = ECF_canCharacterOpenMonitor()
			if (!canOpenMonitor && Game.getSetting(SETTING_MONITOR_BEHAVIOR))
			{
				if (objA1.velocity.y < 0)
				{
					// Make monitors break over the player's head at different orientations. #contributed by Dynamic Lemons
					if ((global.inv_gravity != (objA1.render_flags & render_flag.FLIP_Y) != 0))
						canOpenMonitor = true
				}
			}

			if (canOpenMonitor)
			{
				Character.OnHitMonitor()
				objA1.base_state = 0x04		// Set monitor state to broken
				objA1.monitor.character_address = A0.u16		// RAM address of character
			}
		}
	}
	else if (D1.u8 == collision.flag.THREAT)
	{
		// Harmful object
		Character.OnThreatCollision()
	}
	else  // D1.u8 == collision.flag.SPECIAL
	{
		// Other interactable object
		fn0103ba()
	}
}

function void Character.OnHitBoss()
{
	char.velocity.x = -char.velocity.x
	char.velocity.y = -char.velocity.y
	char.groundspeed = -char.groundspeed
}

function void Character.OnHitBadnik()
{
	if (char.velocity.y < 0)
		char.velocity.y += 0x100
	else if (char.position.y.u16 >= objA1.position.y.u16)
		char.velocity.y -= 0x100
	else
		char.velocity.y = -char.velocity.y
}

function void Character.OnHitMonitor()
{
	// Calculate if the player is moving up, specifically relative to the monitor
	s16 vy = char.velocity.y - objA1.velocity.y

	bool movingUp = (vy < 0)		// Velocity is normalised for inverted gravity anyway, so no need for fancy conditional checks

	// If player and monitor are at different orientations, check if player is moving down instead of up
	if ((objA1.render_flags & render_flag.FLIP_Y) != (char.render_flags & render_flag.FLIP_Y))
	{
		movingUp = !movingUp

		if (char.flags & char.flag.IN_AIR)
			objA1.flags2a &= ~object.flag.P1_PUSHING
	}

	movingUp = (movingUp && (abs(char.position.x.u16 - objA1.position.x.u16) < 0x12 || char.state == char.state.ROLLING))		// only bounce at a certain distance, otherwise push the player away when falling, #contributed by GFX32
	if (!movingUp)
	{
		// Bounce off
		char.velocity.y = -char.velocity.y
	}
}

//# address-hook(0x01d696) end(0x01d6be)
function void MonitorIntact.CheckBlocking()
{
	if (getECFCharBufferName(A1) == 0 || ECF_disableBranchBase)
	{
		base.MonitorIntact.CheckBlocking()
		return
	}
	
	u8 bit = (1 << D6.u8)
	if (objA0.flags2a & bit)
	{
		fn01d6dc()
	}
	else
	{
		// Note that "Character.OnCollisionWithDynamicObject" does the same checks again

		bool canOpenMonitor = ECF_canCharacterOpenMonitor(A1, A0)
	#if STANDALONE
		if (!canOpenMonitor && Game.getSetting(SETTING_MONITOR_BEHAVIOR))
		{
			if (objA0.velocity.y > 0)		// Fixed some unintentional interactions, #contributed by iCloudius
				canOpenMonitor = true
		}
	#endif

		if (!canOpenMonitor)
		{
			// Block character movement
			fn01df90()
		}
	}
}

//# address-hook(0x0857c2) end(0x0857e6)
function void fn0857c2()
{
	if (getECFCharBufferName(A1) == 0 || ECF_disableBranchBase)
	{
		base.fn0857c2()
		return
	}
	
	if (u8[A1 + 0x2b] & char.bonus.INVINCIBLE || ECF_isCharacterAttacking(A1, A0))
	{
		fn085822()
		return
	}

	// could force run Sonic's here, but still doing this table redirect for safety reasons.
	// Targets:
	//  - 0x0857f0	-> u8[A1 + 0x38] = CHARACTER_SONIC
	//  - 0x0857f4	-> u8[A1 + 0x38] = CHARACTER_TAILS
	//  - 0x085826	-> u8[A1 + 0x38] = CHARACTER_KNUCKLES
	D0 = u8[A1 + 0x38] * 2
	call tableLookupAddress(0x0857ea, D0.u16)
}

//# address-hook(0x0857f4) end(0x085824)
function void fn0857f4()
{
	if (getECFCharBufferName(A1) == 0)
		base.fn0857f4()
	else
	{
		D0 = 0
		_setZeroFlagByValue(0)
	}
}

//# address-hook(0x085826) end(0x085836)
function void fn085826()
{
	if (getECFCharBufferName(A1) == 0)
		base.fn085826()
	else
	{
		D0 = 0
		_setZeroFlagByValue(0)
	}
}

// remove super sonic stats

function void setSpeedCapProperties(u32 address, bool isSuperActive)
{
	if (getECFCharBufferName(A0) == 0 || ECF_disableBranchBase)
	{
		base.setSpeedCapProperties(address, isSuperActive)
		return
	}
	
	// Set new max speed cap etc.:
	//  - u16[address]     = maximum speed			-> e.g. global.move.speedcap
	//  - u16[address + 2] = maximum acceleration	-> e.g. global.move.acceleration
	//  - u16[address + 4] = maximum deceleration	-> e.g. global.move.deceleration

	if (char.flags & char.flag.UNDERWATER)
	{
		// In water
	#if STANDALONE
		if (char.bonus_effect & char.bonus.SPEED_UP)
		{
			u16[address] = max(u16[address], 0x600)
			u16[address + 2] = max(u16[address + 2], 0x0c)
			u16[address + 4] = max(u16[address + 4], 0x40)
		}
		else
	#endif
		if (isSuperActive)
		{
			u16[address] = 0x400
			u16[address + 2] = 0x0c
			u16[address + 4] = 0x60
		}
		else
		{
			u16[address] = 0x300
			u16[address + 2] = 0x06
			u16[address + 4] = 0x40
		}
	}
	else
	{
		// Out of water
	#if STANDALONE
		if (char.bonus_effect & char.bonus.SPEED_UP)
		{
			u16[address] = max(u16[address], 0xc00)
			u16[address + 2] = max(u16[address + 2], 0x18)
			u16[address + 4] = max(u16[address + 4], 0x80)
		}
		else
	#endif
		if (isSuperActive)
		{
			u16[address] = 0x800
			u16[address + 2] = 0x18
			u16[address + 4] = 0xc0
		}
		else
		{
			u16[address] = 0x600
			u16[address + 2] = 0x0c
			u16[address + 4] = 0x80
		}
	}
}

// don't use super anims
//# address-hook(0x012600) end(0x01286c)
//# translated(0x012a2a) end(0x012a6e)
function void UpdateSonicAnimation()
{
	if (getECFCharBufferName(A0) == 0)
	{
		base.UpdateSonicAnimation()
		return
	}
	
	if (char.state != char.state.former)
	{
		char.state.former = char.state
		char.animation.frame = 0
		char.animation.timer = 0
		char.flags &= ~char.flag.PUSHING
	}

	A1 = (Character.getSuperState() && char.state <= char.state.TRANSFORMING && ECF_charHasSeparateSuperAnims()) ? 0x012c3a : 0x012aa6		// Fixed Super Sonic missing some animation states
	A1 = tableLookupAddress(A1, char.state * 2)
	D0.u8 = u8[A1]

	// D0.u8 is either:
	//  - 0xff when running
	//  - 0xfe when rolling (on ground or in air)
	//  - between 0x00 and 0x7f in other cases (like standing, balancing, spring-jumping, getting hurt, etc.)

	if (D0.u8 < 0x80)
	{
		updateSonicAnimationStanding()
	}
	else if (D0.u8 == 0xff)
	{
		updateSonicAnimationRunning()
	}
	else // if (D0.u8 == 0xfe)
	{
		updateSonicAnimationRolling()
	}
}

function void updateSonicAnimationRunning()
{
	if (char.character != CHARACTER_SONIC || A1 == 0x012c7a || getECFCharBufferName(A0) == 0 || ECF_disableBranchBase) // no super sonic run if we are not using super animation
	{
		base.updateSonicAnimationRunning()
		return
	}
	
	D0 = 0
	if ((char.flags2d & 0x80) || char.rotation.x != 0)
	{
		updateCharacterAnimationRunning_shared()
	}
	else
	{
		D0.u8 = (s8(char.rotation) > 0) ? (char.rotation - 1) : char.rotation
		D2.u8 = char.flags & char.flag.FACING_LEFT
		if (D2.u8 == 0)
			D0.s8 = -D0.s8 - 1

		D0.u8 += 0x10
		D1 = (D0.u8 & 0x80) ? (render_flag.FLIP_X | render_flag.FLIP_Y) : 0
		D2.u8 ^= D1.u8

		char.render_flags &= ~(render_flag.FLIP_X | render_flag.FLIP_Y)
		char.render_flags |= D2.u8

		if (char.flags & char.flag.PUSHING)
		{
			updateSonicAnimationPushing()
			return
		}

		D0.u8 = (D0.u8 >> 4) & 0x06
		D2.u16 = abs(char.groundspeed)
		if (char.bonus_effect & char.bonus.INFINITE_INERTIA)
			D2.u16 *= 2

		if (D2.u16 < 0x600)
		{
			// Sonic's walking animation
			A1 = 0x012aee
			D3.u8 = D0.u8 * 4
		}
		else
		{
			// Sonic's running animation
			A1 = 0x012af8
			D3.u8 = D0.u8 * 2
		}

		D0.u8 = u8[A1 + char.animation.frame + 1]	// Load next animation frame byte
	#if STANDALONE
		if (D0.u8 >= 0xfe)		// 0xfe is possible in rare cases when Sonic touches ground while being carried by Tails
	#else
		if (D0.u8 == 0xff)
	#endif
		{
			// Loop animation from the start
			char.animation.frame = 0
			D0.u8 = u8[A1 + 1]
		}

		char.animation.sprite = D0.u8 + D3.u8		// Change sprites based on rotations
		--char.animation.timer
		if (s8(char.animation.timer) < 0)
		{
			char.animation.timer = max(0x800 - D2.s16, 0) >> 8
			++char.animation.frame
		}
	}
}

//# address-hook(0x08167c) end(0x0816ee)
function void fn08167c()
{
	if (getECFCharBufferName(0xffffb000) == 0 || ECF_disableBranchBase)
	{
		base.fn08167c()
		return
	}
	
	objA0.velocity.y -= 0x20
	UpdateMovementStraightSimple()

	A1 = 0xffffb000
	if (u8[A1 + 0x2e] != 0)
		return

	objA0.base_state = 0x06
	objA0.velocity.x = 0
	objA0.velocity.y = 0
	objA0.flags38 |= 0x04
	u8[A1 + 0x2e] = control_flag.DISABLE_UPDATE
	objA1.state = char.state.RUNNING
	objA1.velocity.x = 0x1000
	u16[A1 + 0x1c] = 0x1000

	if (global.super_emeralds != 7)
	{
		u32[0xffffcbc0] = 0x08242a		// Super Sonic stars in Doomsday Zone
	}
	else
	{
		fn05fcce()
		u32[0xffffcd7c] = 0x019348		// Hyper Sonic stars
		u32[0xffffcbc0] = addressof(AfterImages.Init)		// After-images effect
	}

	addPatternLoadingCue(0x083d64)		// Boss explosion sprites
}