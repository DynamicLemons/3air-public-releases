constant u8 char.state.AMY_HAMMERSPIN_N = 0x20
constant u8 char.state.AMY_HAMMERSPIN_H = 0x21
constant u8 char.state.AMY_TWINSPIN = 0x22

//# address-hook(0x012600) end(0x01286c)
//# translated(0x012a2a) end(0x012a6e)
function void UpdateSonicAnimation()
{
	if (!isECFCharA0("ECC-Amy"))
	{
		base.UpdateSonicAnimation()
		return
	}
	
	bool specialChange = false
	if (char.state != char.state.former)
	{
		if (char.state == char.state.AMY_HAMMERSPIN_N && char.state.former == char.state.ROLLING || char.state == char.state.ROLLING && char.state.former == char.state.AMY_HAMMERSPIN_N)
		{
			char.state.former = char.state
			specialChange = true
		}
		else
		{
			char.state.former = char.state
			char.animation.frame = 0
			char.animation.timer = 0
		}
		char.flags &= ~char.flag.PUSHING
	}

	A1 = tableLookupAddress(0x012aa6, char.state * 2)
	D0.u8 = u8[A1]

	// D0.u8 is either:
	//  - 0xff when running
	//  - 0xfe when rolling (on ground or in air)
	//  - between 0x00 and 0x7f in other cases (like standing, balancing, spring-jumping, getting hurt, etc.)

	if (char.state == char.state.STANDING)
	{
		constant array<u8> AniTable = 
		{
			10,
			// Very Short Stance
			0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba,
			0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba,
			0xba, 0xba, 0xba, 0xba, 0xba,
			// Actual Idle
			0xbb, 0xbb, 0xbc, 0xbc, 0xbb, 0xbb, 0xbd, 0xbd,
			0xbb, 0xbb, 0xbc, 0xbc, 0xbb, 0xbb, 0xbd, 0xbd,
			0xbb, 0xbb, 0xbc, 0xbc, 0xbb, 0xbb, 0xbd, 0xbd,
			0xbb, 0xbb, 0xbc, 0xbc, 0xbb, 0xbb, 0xbd, 0xbd,
			0xbb, 0xbb, 0xbc, 0xbc, 0xbb, 0xbb, 0xbd, 0xbd,
			0xbb, 0xbb, 0xbc, 0xbc, 0xbb, 0xbb, 0xbd, 0xbd,
			0xbb, 0xbb, 0xbc, 0xbc, 0xbb, 0xbb, 0xbd, 0xbd,
			0xbb, 0xbb, 0xbc, 0xbc, 0xbb, 0xbb, 0xbd, 0xbd,
			// Transition to Bored 
			0xbe, 0xbe, 
			0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,
			// Bored 
			0xc0, 0xc0, 0xc0, 0xc0, 0xc1, 0xc0, 0xc1, 0xc0, 
			0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
			0xc0, 0xc0, 0xc0, 0xc0, 0xc1, 0xc0, 0xc1, 0xc0, 
			0xc0, 0xc0, 0xc0, 0xc0,
			// Transition from Bored
			0xc1, 0xc0, 0xc2, 
			// reset
			0xff
		}

		D1.u8 = char.flags & char.flag.FACING_LEFT
		char.render_flags = (char.render_flags & ~(render_flag.FLIP_X | render_flag.FLIP_Y)) | D1.u8
		
		A1 = 0x800000
		for (u8 i = 0; i < AniTable.length(); ++i)
			u8[A1 + i] = AniTable[i]
		D0.u8 = AniTable[0]
		
		updateSonicAnimationStanding()
	}
	else if (char.state == char.state.BALANCING2)
	{
		constant array<u8> AniTable = 
		{
			5,
			0xa1, 0xa2, 0xa3,
			0xff
		}

		D1.u8 = char.flags & char.flag.FACING_LEFT
		char.render_flags = (char.render_flags & ~(render_flag.FLIP_X | render_flag.FLIP_Y)) | D1.u8
		
		A1 = 0x800000
		for (u8 i = 0; i < AniTable.length(); ++i)
			u8[A1 + i] = AniTable[i]
		D0.u8 = AniTable[0]
		
		updateSonicAnimationStanding()
	}
#if LEMONS_TWEAKS_ACTIVE
	else if (char.state == char.state.BRAKING)
	{
		constant array<u8> AniTable = 
		{
			3,
			
			0x9d, 0x9e,
			0xfc,

			0xa0,
			0xfe, 1
		}

		D1.u8 = char.flags & char.flag.FACING_LEFT
		char.render_flags = (char.render_flags & ~(render_flag.FLIP_X | render_flag.FLIP_Y)) | D1.u8

		A1 = 0x800000
		for (u8 i = 0; i < AniTable.length(); ++i)
			u8[A1 + i] = AniTable[i]
		D0.u8 = AniTable[0]
		
		if (char.animation.frame <= 2 && abs(char.groundspeed) < 0x200)
		{
			char.animation.frame = 4
			char.animation.sprite = AniTable[char.animation.frame]
			char.animation.timer = AniTable[0]
		}
		else if (objA0.animation.timer == 0) && (AniTable[char.animation.frame + 1] == 0xfc)
		{
			bool check = false 
			
			if (char.flags & char.flag.FACING_LEFT)
				check = (char.groundspeed < -0x200)
			else
				check = (char.groundspeed > 0x200)
				
			if (check)
			{
				char.animation.frame = 2
				char.animation.sprite = AniTable[char.animation.frame]
				char.animation.timer = AniTable[0]
			}
			else
			{
				char.animation.frame += 2
				char.animation.sprite = AniTable[char.animation.frame]
				char.animation.timer = AniTable[0]
			}
		}
		else
			updateSonicAnimationStanding()
	}
#endif
	else if (char.state == char.state.WIN_POSE)
	{
		constant array<u8> AniTable = 
		{
			6,
			0xb0, 0xb1, 0xb2, 0xb3,
			0xfe, 1,
			
			0xb0, 0xff,
			
			0xb0, 0xfe, 1
		}

		D1.u8 = char.flags & char.flag.FACING_LEFT
		char.render_flags = (char.render_flags & ~(render_flag.FLIP_X | render_flag.FLIP_Y)) | D1.u8
		
		A1 = 0x800000
		for (u8 i = 0; i < AniTable.length(); ++i)
			u8[A1 + i] = AniTable[i]
		D0.u8 = AniTable[0]
		
		updateSonicAnimationStanding()
		
	}
	else if (char.state == char.state.TRANSFORMING)
	{
		constant array<u8> AniTable = 
		{
			2,
			0xc5, 0xc5,
			0xc6, 0xc7, 0xc6, 0xc7, 0xc6,
			0xc7, 0xc6, 0xc7, 0xc6, 0xc7,
			0xfd, 0
		}

		D1.u8 = char.flags & char.flag.FACING_LEFT
		char.render_flags = (char.render_flags & ~(render_flag.FLIP_X | render_flag.FLIP_Y)) | D1.u8
		
		--char.animation.timer
		if (s8(char.animation.timer) < 0)
		{
			D0.u8 = AniTable[char.animation.frame+1]
			char.animation.timer = AniTable[0]
			if (D0.u8 < 0xfc)
			{
				// Advance to next frame
				char.animation.sprite = D0.u8
				++char.animation.frame
			}
			else if (D0.u8 == 0xfd)
			{
				// Change to another animation
				char.state = AniTable[char.animation.frame + 2]
			}
		}
	}
	else if (char.state == char.state.AMY_HAMMERSPIN_N)
	{
		updateSonicAnimationRolling()
	}
	else if (char.state == char.state.AMY_HAMMERSPIN_H)
	{
		constant array<u8> AniTable = 
		{
			1,
			0xd0, 0xd1,
			0xff
		}

		D1.u8 = char.flags & char.flag.FACING_LEFT
		char.render_flags = (char.render_flags & ~(render_flag.FLIP_X | render_flag.FLIP_Y)) | D1.u8
		
		A1 = 0x800000
		for (u8 i = 0; i < AniTable.length(); ++i)
			u8[A1 + i] = AniTable[i]
		D0.u8 = AniTable[0]
		
		updateSonicAnimationStanding()
	}
	else if (char.state == char.state.AMY_TWINSPIN)
	{
		constant array<u8> AniTable = 
		{
			1,
			0xd2, 0xd3, 0xd4, 0xd3, 0xd2, 0xd5, 0xd6, 0xd5,
			0xff
		}

		constant array<u8> Flipped = 
		{
			0, 0, 0, 1, 1, 0, 0, 1,
		}
		
		D1.u8 = char.flags & char.flag.FACING_LEFT
		char.render_flags = (char.render_flags & ~(render_flag.FLIP_X | render_flag.FLIP_Y)) | D1.u8
		
		A1 = 0x800000
		for (u8 i = 0; i < AniTable.length(); ++i)
			u8[A1 + i] = AniTable[i]
		D0.u8 = AniTable[0]
		
		updateSonicAnimationStanding()
		
		if (Flipped[char.animation.frame - 1])
			char.render_flags ^= render_flag.FLIP_X
	}
	else if (char.state >= 0x31)
		base.UpdateSonicAnimation()
	else if (D0.u8 < 0x80)
		updateSonicAnimationStanding()
	else if (D0.u8 == 0xff)
		updateSonicAnimationRunning()
	else // if (D0.u8 == 0xfe)
		updateSonicAnimationRolling()
}